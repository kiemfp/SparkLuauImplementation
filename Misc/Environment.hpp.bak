#include <iostream>
#include <string>
#include <vector>

#include <cstring>
#include <cstdio>
#include <cstdlib>

//#include <Misc/Environment.hpp>//yeah copied from entry

#include <Luau/Compiler.h>
#include <Luau/BytecodeBuilder.h>
#include <Luau/BytecodeUtils.h>
#include <Luau/Bytecode.h>
#include <luacode.h>

#include <lapi.h>
#include <lstate.h>
#include <lualib.h>
#include <lualib.h>
#include <luaconf.h>
#include <ldebug.h>
#include <ltable.h>
#include "ldebug.h"
//#include "lapi.h"
#include "lfunc.h"
#include "lmem.h"
#include "lgc.h"
#include "ldo.h"
#include "lbytecode.h"
#include "lua.h"


char* luau_compileW(const char* source, size_t size, lua_CompileOptions* options, size_t* outsize, std::string* ErrMsg)
{
    LUAU_ASSERT(outsize);

    Luau::CompileOptions opts;

    if (options)
    {
        static_assert(sizeof(lua_CompileOptions) == sizeof(Luau::CompileOptions), "C and C++ interface must match");
        memcpy(static_cast<void*>(&opts), options, sizeof(opts));
    }

    std::string result = Luau::compile(std::string(source, size), opts);

    if (result.empty())
    {
        if (ErrMsg) {
            *ErrMsg = "Luau compilation failed: invalid syntax or other compilation error (result was empty).";
        }
        *outsize = 0;

        if (ErrMsg) {
            std::cerr << "DEBUG (luau_compileW): Error: '" << *ErrMsg << "'" << std::endl;
        } else {
            std::cerr << "DEBUG (luau_compileW): Error Message pointer is null." << std::endl;
        }

        return nullptr;
    }

    char* copy = static_cast<char*>(malloc(result.size()));
    if (!copy) {
        if (ErrMsg) {
            *ErrMsg = "Memory allocation failed for bytecode.";
        }
        *outsize = 0;
        return nullptr;
    }

    memcpy(copy, result.data(), result.size());
    *outsize = result.size();
    return copy;
}
namespace Env{

//int 

static int warn(lua_State* L) {
    if (lua_gettop(L) >= 1 /*&& lua_isstring(L, 1)*/) {
        size_t len;
        const char* warning_message = lua_tolstring(L, 1, &len);
        std::cout << "[Warning]: " << (warning_message ? std::string(warning_message, len) : "<nil or non-string argument>") << std::endl; //too lazy to make it auto tostring
    } else {
        std::cerr << "[Warning]: Luau 'warn' function called with no arguments." << std::endl;
    }
    lua_pushboolean(L, 1);
    return 1;
}

int getrawmetatable(lua_State* LS) {
    luaL_checkany(LS, 1);

    if (!lua_getmetatable(LS, 1))
        lua_pushnil(LS);

    return 1;
};

int getgenv(lua_State* L) {/*
    #ifdef LUA_ENVIRONINDEX
        luaL_sandboxthread(L);
        lua_pushvalue(L, LUA_ENVIRONINDEX);*/
    //#else
        lua_pushvalue(L, LUA_GLOBALSINDEX); // that's what we want, got confused :P
        //std::cerr << "Warning: luaL_sandboxthread not available or LUA_ENVIRONINDEX not defined. Returned LUA_GLOBALSINDEX." << std::endl;
    //#endif

    return 1;
}

int getreg(lua_State* L) {
    lua_pushvalue(L, LUA_REGISTRYINDEX);
    return 1;
}


int loadstring(lua_State* LS) {
    luaL_checktype(LS, 1, LUA_TSTRING);

    size_t sourceLen;
    const char* Source = lua_tolstring(LS, 1, &sourceLen);
    const char* ChunkName = luaL_optstring(LS, 2, "@Spark" ); // definitely Roblox2 

    size_t bytecodeSize;
    std::string compileErrorMessage;
    char* Bytecode = luau_compileW(Source, sourceLen, NULL, &bytecodeSize, &compileErrorMessage);

    if (!Bytecode) {
        lua_pushnil(LS); // return nil
        if (!compileErrorMessage.empty()) {
            lua_pushstring(LS, compileErrorMessage.c_str());
        } else {
            lua_pushstring(LS, "Failed to compile Luau code.");
        }
        return 2; // (nil, errmsg)
    }

    int loadStatus = luau_load(LS, ChunkName, Bytecode, bytecodeSize, LUA_GLOBALSINDEX);

    free(Bytecode);

    if (loadStatus != LUA_OK) {
        // err msg should be stack top
        lua_pushboolean(LS, 0); // changed to return false
        lua_insert(LS, -2); // sets err msg to second r_arg
        return 2; // (false, err msg) 
    }

    // ret only f arg which is load' ret
    return 1;
}


// custom C d.getinfo(doesn't work at all) 
static int lua_debug_info(lua_State* L) { //made this with AI, so shitty asf. Yeah I could just check Lua or luau source to add it, but, nah... 
    // Arg 1: func to spec
    // Arg 2: what should be spec
    luaL_checktype(L, 1, LUA_TFUNCTION);
    luaL_checkstring(L, 2);

    lua_Debug ar;
    const char* what_arg = lua_tostring(L, 2);

    
    char what_with_prefix[32];
    if (strlen(what_arg) >= sizeof(what_with_prefix) - 1) {
        luaL_error(L, "debug.info: 'what' string too long");
    }
    snprintf(what_with_prefix, sizeof(what_with_prefix), ">%s", what_arg);


    // set it to top of stack
    // Hope it will be >
    // // and 'level' 0 refers to it. //tf that means? 
    lua_pushvalue(L, 1);

    // Call lua_getinfo. The function is at stack top (index 3 now) after lua_pushvalue.
    // '0' level means "current function" or "function at top of stack" when '>' is used.
    int success = lua_getinfo(L, 0, what_with_prefix, &ar);

    // Pop the duplicated function from the stack (at index -1)
    lua_pop(L, 1);

    if (!success) {
        lua_pushnil(L); // Return nil if info retrieval failed
        return 1;
    }

    // Create a new table to return the debug information
    lua_newtable(L);

    // Populate the table based on the 'what' string and the ar struct
    if (strchr(what_arg, 'S')) { // Source information
        lua_pushstring(L, "source");
        lua_pushlstring(L, ar.source, ar.source ? strlen(ar.source) : 0); // Use strlen as srclen is not available
        lua_settable(L, -3);

        lua_pushstring(L, "short_src");
        lua_pushstring(L, ar.short_src);
        lua_settable(L, -3);
    }

    if (strchr(what_arg, 'n')) { // Name information
        lua_pushstring(L, "name");
        lua_pushstring(L, ar.name ? ar.name : ""); // Ensure not null
        lua_settable(L, -3);

        // 'namewhat' is not available in your lua_Debug struct, so we skip it
    }

    if (strchr(what_arg, 'l')) { // Current line information
        lua_pushstring(L, "currentline");
        lua_pushinteger(L, ar.currentline);
        lua_settable(L, -3);
    }

    if (strchr(what_arg, 'f')) { // The function itself
        lua_pushstring(L, "func");
        lua_pushvalue(L, 1); // Push the original function argument back
        lua_settable(L, -3);
    }

    if (strchr(what_arg, 'L')) { // Line table information
        // 'lastlinedefined' is not available in your lua_Debug struct
        lua_pushstring(L, "linedefined");
        lua_pushinteger(L, ar.linedefined);
        lua_settable(L, -3);
    }

    if (strchr(what_arg, 'w')) { // what field
        lua_pushstring(L, "what");
        lua_pushstring(L, ar.what ? ar.what : "");
        lua_settable(L, -3);
    }

    // You can add more 'what' options and corresponding ar fields as needed.
    // Refer to `lua_Debug` struct in Luau's `ldebug.h` for all available fields.

    return 1; // Return the table
}

int setrawmetatable(lua_State* L) { // ni
    luaL_checkany(L, 1); //should not be nil

    std::intptr_t t = lua_type(L, 2); // get type
    luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2, "nil or table should be provided");

    lua_settop(L, 2);
    lua_pushboolean(L, lua_setmetatable(L, 1));

    return 1;
}




/* //I don't have Table* for some reason.
int setreadonly(lua_State* L) -> std::intptr_t {
    luaL_checktype(L, 1, LUA_TTABLE);
    luaL_checktype(L, 2, LUA_TBOOLEAN);

    Table* t = (Table*)lua_topointer(L, 1);
    t->readonly = lua_toboolean(L, 2);

    return 0;
}

int isreadonly(lua_State* L) -> std::intptr_t {
    luaL_checktype(L, 1, LUA_TTABLE);

    Table* t = (Table*)lua_topointer(L, 1);
    lua_pushboolean(L, t->readonly);

    return 1;
}

int iswriteable(lua_State* L) -> std::intptr_t {
    luaL_checktype(L, 1, LUA_TTABLE);

    Table* t = (Table*)lua_topointer(L, 1);
    lua_pushboolean(L, !t->readonly);

    return 1;
}

int makereadonly(lua_State* L) -> std::intptr_t {
    luaL_checktype(L, 1, LUA_TTABLE);

    Table* t = (Table*)lua_topointer(L, 1);
    t->readonly = TRUE;

    return 0;
}

int makewriteable(lua_State* L) -> std::intptr_t {
    luaL_checktype(L, 1, LUA_TTABLE);

    Table* t = (Table*)lua_topointer(L, 1);
    t->readonly = FALSE;

    return 0;
}*/

int getnamecallmethod(lua_State* L){
	if (auto namecall = L->namecall) {
		lua_pushstring(L, namecall->data);
		return 1;
	}
	return 0;
}

int setnamecallmethod(lua_State* L){
    luaL_checktype(L, 1, LUA_TSTRING);
    L->namecall = tsvalue(luaA_toobject(L, 1));

    return 0;
}






void registerFunctions(lua_State* L){
    lua_pushcclosurek(L, Env::warn, NULL, 0, NULL);
    lua_setglobal(L, "warn");
    std::cout << "C++ function 'warn' registered with Luau." << std::endl;

    lua_pushcclosurek(L, Env::getrawmetatable, NULL, 0, NULL);
    lua_setglobal(L, "getmeta");
    std::cout << "C++ function 'getmeta' registered with Luau." << std::endl;

    lua_pushcclosurek(L, Env::getgenv, NULL, 0, NULL);
    lua_setglobal(L, "getgenv");
    std::cout << "C++ function 'getgenv' registered with Luau." << std::endl;

    lua_pushcclosurek(L, Env::getreg, NULL, 0, NULL);
    lua_setglobal(L, "getreg");
    std::cout << "C++ function 'getreg' registered with Luau." << std::endl;

    lua_pushcclosurek(L, Env::loadstring, NULL, 0, NULL);
    lua_setglobal(L, "loadstring");
    std::cout << "C++ function 'loadstring' registered with Luau." << std::endl;
/*
    // Register custom debug.info, actually changed to raw metatable
    lua_getglobal(L, "debug"); // Get the debug table
    if (lua_isnil(L, -1)) { // If debug table doesn't exist, create it
        lua_pop(L, 1); // Pop nil
        lua_newtable(L);
    }*/
    lua_pushcclosurek(L, Env::setrawmetatable, NULL, 0, NULL);
    //lua_setfield(L, -2, "info"); // Set debug.info = lua_debug_info
    lua_setglobal(L, "setmeta"); // Put the debug table back to global
    std::cout << "C++ function 'setmeta' registered with Luau.\n" << std::endl;
    
    /*
    lua_pushcclosurek(L, Env::setreadonly, NULL, 0, NULL);
    lua_setglobal(L, "setreadonly");
    std::cout << "C++ function 'setreadonly' registered with Luau." << std::endl;
    
    lua_pushcclosurek(L, Env::isreadonly, NULL, 0, NULL);
    lua_setglobal(L, "isreadonly");
    std::cout << "C++ function 'isreadonly' registered with Luau." << std::endl;
    
    lua_pushcclosurek(L, Env::iswritable, NULL, 0, NULL);
    lua_setglobal(L, "iswritable");
    std::cout << "C++ function 'iswritable' registered with Luau." << std::endl;
    
    lua_pushcclosurek(L, Env::makereadonly, NULL, 0, NULL);
    lua_setglobal(L, "makereadonly");
    std::cout << "C++ function 'makereadonly' registered with Luau." << std::endl;
    
    lua_pushcclosurek(L, Env::makewritable, NULL, 0, NULL);
    lua_setglobal(L, "makewritable");
    std::cout << "C++ function 'makewritable' registered with Luau." << std::endl;
    */
    lua_pushcclosurek(L, Env::getnamecall, NULL, 0, NULL);
    lua_setglobal(L, "getnamecallmethod");
    std::cout << "C++ function 'getnamecallmethod' registered with Luau." << std::endl;
    
    lua_pushcclosurek(L, Env::setnamecallmethod, NULL, 0, NULL);
    lua_setglobal(L, "setnamecallmethod");
    std::cout << "C++ function 'setnamecallmethod' registered with Luau." << std::endl;

    
    std::cout << "Env: Working\n Enter to continue.";//who wants buffer? 
    std::cin;
};

}