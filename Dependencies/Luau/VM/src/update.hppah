#pragma once
//#include "jni.h"
#include <iostream>

template <typename T>
struct unwrap_VMValueue {
    using type = T;
};

template<typename T>
class VMValue0 {
public:
    operator const T() const { return storage; }
    void operator=(const T& value) { storage = value; }
    const T operator->() const { return operator const T(); }
    T get() { return operator const T(); }
    void set(const T& value) { operator=(value); }

private:
    T storage;
};

template<typename T>
class VMValue1 {
public:
    operator const T() const { return (T)((uintptr_t)storage - (uintptr_t)this); }
    void operator=(const T& value) { storage = (T)((uintptr_t)value + (uintptr_t)this); }
    const T operator->() const { return operator const T(); }
    T get() { return operator const T(); }
    void set(const T& value) { operator=(value); }

private:
    T storage;
};

template<typename T>
class VMValue2 {
public:
    operator const T() const { return (T)((uintptr_t)this - (uintptr_t)storage); }
    void operator=(const T& value) { storage = (T)((uintptr_t)this - (uintptr_t)value); }
    const T operator->() const { return operator const T(); }
    T get() { return operator const T(); }
    void set(const T& value) { operator=(value); }

private:
    T storage;
};

template<typename T>
class VMValue3 {
public:
    operator const T() const { return (T)((uintptr_t)this ^ (uintptr_t)storage); }
    void operator=(const T& value) { storage = (T)((uintptr_t)value ^ (uintptr_t)this); }
    const T operator->() const { return operator const T(); }
    T get() { return operator const T(); }
    void set(const T& value) { operator=(value); }

private:
    T storage;
};

template<typename T>
class VMValue4 {
public:
    operator const T() const { return (T)((uintptr_t)this + (uintptr_t)storage); }
    void operator=(const T& value) { storage = (T)((uintptr_t)value - (uintptr_t)this); }
    const T operator->() const { return operator const T(); }
    T get() { return operator const T(); }
    void set(const T& value) { operator=(value); }

private:
    T storage;
};



#define LUAU_COMMA_SEP ,
#define LUAU_SEMICOLON_SEP ;

#define LUAU_SHUFFLE3( s, a1, a2, a3 ) a1 s a2 s a3
#define LUAU_SHUFFLE4( s, a1, a2, a3, a4 ) a1 s a2 s a4 s a3
#define LUAU_SHUFFLE5( s, a1, a2, a3, a4, a5 ) a2 s a4 s a1 s a3 s a5
#define LUAU_SHUFFLE6( s, a1, a2, a3, a4, a5, a6 ) a1 s a4 s a6 s a3 s a2 s a5
#define LUAU_SHUFFLE7( s, a1, a2, a3, a4, a5, a6, a7 ) a6 s a1 s a2 s a5 s a3 s a7 s a4
#define LUAU_SHUFFLE8( s, a1, a2, a3, a4, a5, a6, a7, a8 ) a6 s a3 s a7 s a1 s a5 s a4 s a2 s a8
#define LUAU_SHUFFLE9( s, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) a8 s a2 s a7 s a9 s a4 s a5 s a1 s a6 s a3

#define PROTO_MEMBER1_ENC VMValue0
#define PROTO_MEMBER2_ENC VMValue1
#define PROTO_DEBUGISN_ENC VMValue2
#define PROTO_TYPEINFO_ENC VMValue3
#define PROTO_DEBUGNAME_ENC VMValue4

#define LSTATE_STACKSIZE_ENC VMValue3
#define LSTATE_GLOBAL_ENC VMValue0

#define CLOSURE_FUNC_ENC VMValue0
#define CLOSURE_CONT_ENC VMValue2
#define CLOSURE_DEBUGNAME_ENC VMValue1

#define TABLE_MEMBER_ENC VMValue0
#define TABLE_META_ENC VMValue0

#define UDATA_META_ENC VMValue2

#define TSTRING_HASH_ENC VMValue4
#define TSTRING_LEN_ENC VMValue0

#define GSTATE_TTNAME_ENC VMValue0
#define GSTATE_TMNAME_ENC VMValue0

/*
typedef struct lua_TValue {
    Value value;  /* union w/ pointers, numbers, etc. */
    //int tt;       /* type tag */
    /*
} TValue;
*/

//#ifndef __LUA_VECTOR_SIZE
#define __LUA_VECTOR_SIZE 3 // must be 3 or 4
//#endif

#define __LUA_EXTRA_SIZE (__LUA_VECTOR_SIZE - 2)


typedef union GCObject GCObject;// lobject.h

typedef union //in lobject too. 
{
    GCObject* gc;
    void* p;
    double n;
    int b;
    float v[2]; // v[0], v[1] live here; v[2] lives in TValue::extra
} Value;


typedef struct lua_TValue //removed the Def on lobject.h for better. 
{
    Value value;
    int extra[__LUA_EXTRA_SIZE];
    int tt;
} TValue;
int __LUA_TNIL = 0;
namespace update{
    namespace lua{ //change after
        constexpr TValue luao_nilobject = {{NULL}, {0}, __LUA_TNIL};
        
        
    }
} 